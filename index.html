<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Виртуальная 3D-галерея — Sergeywieden</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;font-family:Arial,sans-serif;background:#eee}
    #overlayUI{
      position:fixed;right:12px;top:12px;z-index:20;background:rgba(255,255,255,0.95);
      padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:320px;
    }
    #descriptionBox{
      position:fixed;left:12px;bottom:12px;z-index:30;
      background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:6px;
      max-width:40%;display:none;
    }
    #descTitle{font-weight:700;margin-bottom:6px}
    #enterHint{
      position:fixed;left:50%;bottom:40px;transform:translateX(-50%);z-index:25;
      background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;
    }
    .paintingLabel{
      pointer-events:none;
      background:rgba(255,255,255,0.95);padding:4px 6px;border-radius:4px;font-size:12px;
      position:fixed;transform:translate(-50%,-50%);white-space:nowrap;z-index:19;
    }
    canvas{display:block}
    button,select,input{font-size:13px}
  </style>
</head>
<body>
  <div id="overlayUI">
    <div><strong>3D-галерея</strong></div>
    <div style="font-size:13px;margin-top:6px">
      Комнаты: 1 (A*), 2 (G*), 3 (S*)<br/>
      Управление: WASD + мышь. Клик на картину — описание.
    </div>
    <div style="margin-top:8px">
      <label><input id="showLabels" type="checkbox" checked/> Показывать подписи</label>
    </div>
    <div style="margin-top:6px">
      <button id="resetPos">Сброс позиции</button>
    </div>
    <div style="margin-top:6px">
      <label>Режим:
        <select id="moveMode">
          <option value="fp">1st-person</option>
          <option value="orbit">Orbit</option>
        </select>
      </label>
    </div>
    <div style="margin-top:6px;font-size:12px;color:#666">Загрузка: <span id="loadStatus">0%</span></div>
  </div>
  <div id="descriptionBox"><div id="descTitle"></div><div id="descText" style="white-space:pre-wrap"></div></div>
  <div id="enterHint">Клик по сцене, чтобы начать (Pointer Lock). ESC — выйти.</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/PointerLockControls.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    // Asset base path for local and GitHub Pages
    const assetsBase = window.location.hostname.includes('github.io') ? '/repository-name/Docs/assets/' : './assets/';
    const manifestPath = assetsBase + 'manifest.json';
    const descriptionsPath = assetsBase + 'descriptions.json';

    let scene, camera, renderer, controlsFP, controlsOrbit, currentControls;
    let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    let paintingsGroup = new THREE.Group();
    let paintingPlanes = [];
    let intersected = null;
    let roomsGroup;
    const roomCount = 3;
    const roomSize = {w:12, h:4, d:12};
    let loadTotal = 0, loadDone = 0;
    const clock = new THREE.Clock();

    async function init(){
      setLoadStatus('Загрузка файлов...');
      try{
        const [manifest, descriptions] = await Promise.all([fetchJSON(manifestPath), fetchJSON(descriptionsPath)]);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdddddd);

        camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 400);
        camera.position.set(0, 1.6, 0);

        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const amb = new THREE.AmbientLight(0xffffff, 0.7);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(5,10,5);
        scene.add(amb, dir);

        roomsGroup = createRooms();
        scene.add(roomsGroup);

        await placePaintings(manifest, descriptions);
        scene.add(paintingsGroup);

        controlsFP = new PointerLockControls(camera, renderer.domElement);
        controlsOrbit = new OrbitControls(camera, renderer.domElement);
        controlsOrbit.enabled = false;
        currentControls = controlsFP;

        renderer.domElement.addEventListener('click', ()=>{
          if(document.getElementById('moveMode').value==='fp'){
            controlsFP.lock();
            document.getElementById('enterHint').style.display='none';
          }
        });

        window.addEventListener('resize', onResize);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('click', onClick);
        document.getElementById('showLabels').addEventListener('change', ev=>toggleLabels(ev.target.checked));
        document.getElementById('resetPos').addEventListener('click', ()=>{ camera.position.set(0,1.6,0); camera.rotation.set(0,0,0); });
        document.getElementById('moveMode').addEventListener('change', ev=>{ ev.target.value==='orbit'?switchOrbit():switchFP(); });

        setupWASD();
        animate();
        setLoadStatus('Готово');
      }catch(err){
        console.error(err);
        setLoadStatus('Ошибка: '+(err.message||err));
      }
    }

    async function fetchJSON(url){
      const r = await fetch(url);
      if(!r.ok) throw new Error('Не удалось загрузить '+url);
      return r.json();
    }

    function setLoadStatus(text){ const el=document.getElementById('loadStatus'); if(el) el.innerText=text; }

    function createRooms(){
      const parent = new THREE.Group();
      const wallThickness = 0.1;
      const floorColor = 0xD2B48C; // Light brown
      const wallColor = 0xE6E6E6; // Light gray
      const ceilingColor = 0xFFFFFF; // White

      for(let i=0; i<roomCount; i++){
        const room = new THREE.Group();
        room.name = `room${i+1}`;
        const xOffset = i * roomSize.w;
        room.position.set(xOffset, 0, 0);

        // Collision bounds
        room.userData.bounds = {
          x: xOffset - roomSize.w/2 + wallThickness,
          x2: xOffset + roomSize.w/2 - wallThickness,
          z: -roomSize.d/2 + wallThickness,
          z2: roomSize.d/2 - wallThickness
        };

        // Floor
        const floorMat = new THREE.MeshStandardMaterial({color: floorColor});
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), floorMat);
        floor.rotation.x = -Math.PI/2;
        floor.position.y = 0;
        room.add(floor);

        // Ceiling
        const ceilMat = new THREE.MeshStandardMaterial({color: ceilingColor});
        const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), ceilMat);
        ceiling.rotation.x = Math.PI/2;
        ceiling.position.y = roomSize.h;
        room.add(ceiling);

        // Walls with doorways
        const wallMat = new THREE.MeshStandardMaterial({color: wallColor});
        const doorWidth = 2;
        const doorHeight = 2.5;

        // North wall
        const northWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.h), wallMat);
        northWall.position.set(0, roomSize.h/2, roomSize.d/2);
        northWall.rotation.y = Math.PI;
        room.add(northWall);

        // South wall
        const southWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.h), wallMat);
        southWall.position.set(0, roomSize.h/2, -roomSize.d/2);
        room.add(southWall);

        // West wall (doorway for i>0)
        if(i === 0){
          const westWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d, roomSize.h), wallMat);
          westWall.position.set(-roomSize.w/2, roomSize.h/2, 0);
          westWall.rotation.y = Math.PI/2;
          room.add(westWall);
        } else {
          const westWall1 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d/2 - doorWidth/2, roomSize.h), wallMat);
          westWall1.position.set(-roomSize.w/2, roomSize.h/2, -roomSize.d/4 - doorWidth/4);
          westWall1.rotation.y = Math.PI/2;
          room.add(westWall1);
          const westWall2 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d/2 - doorWidth/2, roomSize.h), wallMat);
          westWall2.position.set(-roomSize.w/2, roomSize.h/2, roomSize.d/4 + doorWidth/4);
          westWall2.rotation.y = Math.PI/2;
          room.add(westWall2);
          const westLintel = new THREE.Mesh(new THREE.PlaneGeometry(doorWidth, roomSize.h - doorHeight), wallMat);
          westLintel.position.set(-roomSize.w/2, roomSize.h - (roomSize.h - doorHeight)/2, 0);
          westLintel.rotation.y = Math.PI/2;
          room.add(westLintel);
        }

        // East wall (doorway for i<roomCount-1)
        if(i === roomCount-1){
          const eastWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d, roomSize.h), wallMat);
          eastWall.position.set(roomSize.w/2, roomSize.h/2, 0);
          eastWall.rotation.y = -Math.PI/2;
          room.add(eastWall);
        } else {
          const eastWall1 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d/2 - doorWidth/2, roomSize.h), wallMat);
          eastWall1.position.set(roomSize.w/2, roomSize.h/2, -roomSize.d/4 - doorWidth/4);
          eastWall1.rotation.y = -Math.PI/2;
          room.add(eastWall1);
          const eastWall2 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d/2 - doorWidth/2, roomSize.h), wallMat);
          eastWall2.position.set(roomSize.w/2, roomSize.h/2, roomSize.d/4 + doorWidth/4);
          eastWall2.rotation.y = -Math.PI/2;
          room.add(eastWall2);
          const eastLintel = new THREE.Mesh(new THREE.PlaneGeometry(doorWidth, roomSize.h - doorHeight), wallMat);
          eastLintel.position.set(roomSize.w/2, roomSize.h - (roomSize.h - doorHeight)/2, 0);
          eastLintel.rotation.y = -Math.PI/2;
          room.add(eastLintel);
        }

        parent.add(room);
      }
      parent.position.x = -((roomCount-1)*roomSize.w)/2;
      return parent;
    }

    async function placePaintings(manifest, descriptions){
      const loader = new THREE.TextureLoader();
      const keys = ['room1','room2','room3'];
      loadTotal = 0; loadDone = 0;
      keys.forEach(k=>{ if(Array.isArray(manifest[k])) loadTotal+=manifest[k].length; });
      if(loadTotal===0) loadTotal=1;

      for(let r=0; r<3; r++){
        const roomKey = keys[r];
        const list = manifest[roomKey] || [];
        for(let i=0; i<list.length; i++){
          const fname = list[i];
          const url = assetsBase + fname;
          try{
            const tex = await new Promise((res,rej)=>loader.load(url,res,undefined,rej));
            tex.encoding = THREE.sRGBEncoding;
            const aspect = tex.image.width/tex.image.height;
            const height = 1.0;
            const width = Math.max(0.3, height*aspect);
            const mat = new THREE.MeshStandardMaterial({map:tex, emissive:0x000000, emissiveIntensity:1});
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), mat);

            // Frame
            const frameThickness = 0.05;
            const frameDepth = 0.02;
            const frameGeom = new THREE.BoxGeometry(width + frameThickness, height + frameThickness, frameDepth);
            const frameMat = new THREE.MeshStandardMaterial({color:0x6b4226});
            const frame = new THREE.Mesh(frameGeom, frameMat);

            const perWall = Math.ceil(list.length/4);
            const wallIndex = Math.floor(i/perWall)%4;
            const indexOnWall = i%perWall;
            const margin = 0.5;
            const usableLen = roomSize.w - 2*margin;
            let along = -usableLen/2 + (indexOnWall+0.5)*(usableLen/Math.max(1,perWall));
            const roomCenterX = r*roomSize.w - ((3-1)*roomSize.w)/2;
            let px = roomCenterX, pz = 0, rotY = 0, py = 1.6;

            if(wallIndex===0){ px+=along; pz=-roomSize.d/2+0.01; rotY=0; } // South
            else if(wallIndex===1){ px+=along; pz=roomSize.d/2-0.01; rotY=Math.PI; } // North
            else if(wallIndex===2){ px=roomCenterX-roomSize.w/2+0.01; pz=along; rotY=Math.PI/2; } // West
            else{ px=roomCenterX+roomSize.w/2-0.01; pz=along; rotY=-Math.PI/2; } // East

            // Skip paintings in doorways
            if(wallIndex===2 && r>0 && Math.abs(along)<1.5) continue;
            if(wallIndex===3 && r<roomCount-1 && Math.abs(along)<1.5) continue;

            plane.position.set(px, py, pz);
            plane.rotation.y = rotY;
            plane.userData = {file:fname, room:r+1, meta:descriptions[fname]||{}};

            frame.position.set(px, py, pz);
            frame.rotation.y = rotY;
            frame.position.z += -frameDepth/2 - 0.005;

            const label = createLabel(descriptions[fname]?.title || fname);
            plane.userData.labelEl = label;

            paintingsGroup.add(frame);
            paintingsGroup.add(plane);
            paintingPlanes.push({mesh:plane, id:fname, meta:plane.userData.meta});
          }catch(err){
            console.warn('Не удалось загрузить',url,err);
          }finally{
            loadDone++;
            setLoadStatus(Math.round(loadDone/loadTotal*100)+'%');
          }
        }
      }
      paintingPlanes.forEach(p=>p.mesh.geometry.computeBoundingBox());
    }

    function createLabel(text){
      const el = document.createElement('div');
      el.className = 'paintingLabel';
      el.innerText = text;
      el.style.display = document.getElementById('showLabels').checked ? 'block' : 'none';
      document.body.appendChild(el);
      return el;
    }

    function toggleLabels(show){
      paintingPlanes.forEach(p=>{
        if(p.mesh.userData.labelEl) p.mesh.userData.labelEl.style.display = show ? 'block' : 'none';
      });
    }

    function onMouseMove(e){
      mouse.x = (e.clientX/innerWidth)*2-1;
      mouse.y = -(e.clientY/innerHeight)*2+1;
    }

    function onClick(){
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.geometry), true);
      if(intersects.length>0) showDescription(intersects[0].object.userData);
    }

    function showDescription(userData){
      if(!userData) return;
      const box = document.getElementById('descriptionBox');
      document.getElementById('descTitle').innerText = userData.meta?.title || userData.file || 'Картина';
      const author = userData.meta?.author ? ('\nАвтор: '+userData.meta.author) : '';
      document.getElementById('descText').innerText = (userData.meta?.description || 'Описание отсутствует') + author;
      box.style.display = 'block';
      setTimeout(() => box.style.display = 'none', 15000);
    }

    function switchOrbit(){
      if(controlsFP.unlock) controlsFP.unlock();
      controlsOrbit.enabled = true;
      currentControls = controlsOrbit;
    }

    function switchFP(){
      controlsOrbit.enabled = false;
      currentControls = controlsFP;
    }

    function animate(){
      requestAnimationFrame(animate);
      if(currentControls===controlsOrbit) controlsOrbit.update();

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.material), true);
      if(intersects.length>0){
        if(intersected!==intersects[0].object){
          if(intersected?.material?.emissive) intersected.material.emissive.setHex(0x000000);
          intersected = intersects[0].object;
          if(intersected?.material?.emissive) intersected.material.emissive.setHex(0x222222);
        }
      }else{
        if(intersected?.material?.emissive) intersected.material.emissive.setHex(0x000000);
        intersected = null;
      }

      paintingPlanes.forEach(p=>{
        if(p.mesh.userData.labelEl && p.mesh.visible) updateLabelPosition(p.mesh);
      });
      renderer.render(scene, camera);
    }

    function updateLabelPosition(mesh){
      const el = mesh.userData.labelEl;
      if(!el) return;
      const pos = new THREE.Vector3();
      mesh.getWorldPosition(pos);
      pos.project(camera);
      const x = (pos.x*0.5+0.5)*innerWidth;
      const y = (-pos.y*0.5+0.5)*innerHeight;
      el.style.left = x+'px';
      el.style.top = y+'px';
    }

    function onResize(){
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    function setupWASD(){
      const move = {forward:false, back:false, left:false, right:false};
      const direction = new THREE.Vector3();
      const speed = 3.0;

      document.addEventListener('keydown', e=>{
        if(e.code==='KeyW') move.forward=true;
        if(e.code==='KeyS') move.back=true;
        if(e.code==='KeyA') move.left=true;
        if(e.code==='KeyD') move.right=true;
      });
      document.addEventListener('keyup', e=>{
        if(e.code==='KeyW') move.forward=false;
        if(e.code==='KeyS') move.back=false;
        if(e.code==='KeyA') move.left=false;
        if(e.code==='KeyD') move.right=false;
      });

      (function tick(){
        requestAnimationFrame(tick);
        if(currentControls===controlsFP && controlsFP.isLocked){
          const delta = clock.getDelta();
          direction.z = Number(move.forward) - Number(move.back);
          direction.x = Number(move.right) - Number(move.left);
          direction.y = 0;
          if(direction.lengthSq()>0){
            direction.normalize();
            const vel = direction.clone().multiplyScalar(speed*delta);
            const forwardDir = new THREE.Vector3();
            controlsFP.getDirection(forwardDir);
            const rightDir = forwardDir.clone().cross(camera.up).normalize();
            const deltaPos = forwardDir.multiplyScalar(vel.z).add(rightDir.multiplyScalar(vel.x));
            const newPos = camera.position.clone().add(deltaPos);

            let allowed = false;
            roomsGroup.children.forEach(room=>{
              const b = room.userData.bounds;
              if(newPos.x>=b.x && newPos.x<=b.x2 && newPos.z>=b.z && newPos.z<=b.z2){
                allowed = true;
              }
            });

            if(allowed){
              controlsFP.moveForward(vel.z);
              controlsFP.moveRight(vel.x);
            }
          }
          camera.position.y = 1.6;
        }
      })();
    }

    init();
  </script>
</body>
</html>
