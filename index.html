<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Виртуальная 3D-галерея — Sergeywieden</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;font-family:Arial, sans-serif}
    #overlayUI{
      position:fixed;right:12px;top:12px;z-index:20;background:rgba(255,255,255,0.9);
      padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:320px;
    }
    #descriptionBox{
      position:fixed;left:12px;bottom:12px;z-index:30;
      background:rgba(0,0,0,0.75);color:#fff;padding:12px;border-radius:6px;
      max-width:40%;display:none;
    }
    #descTitle{font-weight:700;margin-bottom:6px}
    #enterHint{
      position:fixed;left:50%;bottom:40px;transform:translateX(-50%);z-index:25;
      background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;display:block;
    }
    canvas{display:block}
    .paintingLabel{
      pointer-events:none;
      background:rgba(255,255,255,0.9);padding:4px 6px;border-radius:4px;font-size:12px;
    }
  </style>
</head>
<body>
  <div id="overlayUI">
    <div><strong>3D-галерея</strong></div>
    <div style="font-size:13px;margin-top:6px">
      Комнаты: 1 (A*), 2 (G*), 3 (S*)<br/>
      Управление: WASD + мышь. Клик на картину — описание.
    </div>
    <div style="margin-top:8px">
      <label><input id="showLabels" type="checkbox" checked/> Показывать подписи</label>
    </div>
    <div style="margin-top:6px">
      <button id="resetPos">Сброс позиции</button>
    </div>
    <div style="margin-top:6px">
      <label>Режим: <select id="moveMode"><option value="fp">1st-person</option><option value="orbit">Orbit</option></select></label>
    </div>
    <div style="margin-top:6px;font-size:12px;color:#666">Загрузка: <span id="loadStatus">0%</span></div>
  </div>

  <div id="descBox"></div>
  <div id="descriptionBox"><div id="descTitle"></div><div id="descText" style="white-space:pre-wrap"></div></div>
  <div id="enterHint">Нажмите мышь, чтобы начать (Pointer Lock)</div>

  <!-- three.js (r137+) и утилиты с CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://unpkg.com/lil-gui@0.18.0/dist/lil-gui.min.js"></script>

  <script>
  // === Настройки ===
  const ASSETS_BASE = './assets/'; // папка с изображениями и файлами JSON
  const MANIFEST_PATH = ASSETS_BASE + 'manifest.json';
  const DESCRIPTIONS_PATH = ASSETS_BASE + 'descriptions.json';

  let scene, camera, renderer, controlsFP, controlsOrbit, currentControls;
  let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
  let paintingsGroup = new THREE.Group();
  let gui;
  let INTERSECTED;
  let roomSize = {w:12, h:4, d:12}; // размеры комнат (метафора)
  let paintingPlanes = []; // список объектов картин {mesh, id, meta}

  init();

    // правильные пути (с учётом, что всё в папке assets)
    const MANIFEST_PATH = "./assets/manifest.json";
const DESCRIPTIONS_PATH = "./assets/descriptions.json";

  async function init(){
    // загрузить manifest и descriptions
    const [manifest, descriptions] = await Promise.all([loadJSON(MANIFEST_PATH), loadJSON(DESCRIPTIONS_PATH)]);
    document.getElementById('loadStatus').innerText = 'Загрузка файлов...';

    // базовая сцена
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 1.6, 0);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // свет
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5,10,7);
    scene.add(ambient, dir);

    // GUI для света
    gui = new lil.GUI({container: document.getElementById('overlayUI')});
    const lightFolder = gui.addFolder('Освещение');
    lightFolder.add(ambient, 'intensity', 0, 2, 0.01).name('Ambient').onChange(()=>{});
    lightFolder.add(dir, 'intensity', 0, 3, 0.01).name('Directional');
    lightFolder.open();

    // подготовить комнаты
    const rooms = createRooms(3);
    scene.add(rooms);

    // загрузить и разместить картины по комнатам согласно manifest
    await placePaintings(manifest, descriptions);

    scene.add(paintingsGroup);

    // пол/потолок/стены можно добавить как плоскости (визуально)
    addRoomVisuals();

    // Контролы
    controlsFP = new THREE.PointerLockControls(camera, renderer.domElement);
    controlsOrbit = new THREE.OrbitControls(camera, renderer.domElement);
    currentControls = controlsFP;

    // события
    window.addEventListener('resize', onResize);
    document.addEventListener('click', onDocumentClick);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    document.getElementById('showLabels').addEventListener('change', e=> toggleLabels(e.target.checked));
    document.getElementById('resetPos').addEventListener('click', ()=> {
      camera.position.set(0,1.6, 0); camera.rotation.set(0,0,0);
    });
    document.getElementById('moveMode').addEventListener('change', ev=>{
      if(ev.target.value==='orbit'){ switchToOrbit(); } else { switchToFP(); }
    });

    // PointerLock старт: подсказка
    document.addEventListener('click', function startPointer(){
      const hint = document.getElementById('enterHint');
      if(hint) hint.style.display = 'none';
      document.removeEventListener('click', startPointer);
    });

    animate();
    document.getElementById('loadStatus').innerText = 'Готово';
  }

  // --- utility loader ---
  function loadJSON(url){
    return fetch(url).then(r=>{ if(!r.ok) throw new Error('JSON load failed: '+url); return r.json(); });
  }

  // === Создание комнат (каркас) ===
  function createRooms(count){
    const parent = new THREE.Group();
    // расположим комнаты в ряд по X
    const gap = 2;
    for(let i=0;i<count;i++){
      const room = new THREE.Group();
      room.name = `room${i+1}`;
      const xOffset = i * (roomSize.w + gap);
      room.position.set(xOffset, 0, 0);
      parent.add(room);
      // отметка координат комнаты для располож. картин
      room.userData.bounds = {x:xOffset - roomSize.w/2, x2: xOffset + roomSize.w/2, z:-roomSize.d/2, z2: roomSize.d/2};
    }
    // сместим весь каркас так, чтобы центр был в (0,0)
    parent.position.x = -((count-1)*(roomSize.w+gap))/2;
    return parent;
  }

  // === Размещение картин по стенам ===
  async function placePaintings(manifest, descriptions){
    // manifest должен содержать: { "room1": ["paintingA01.jpg",...], "room2": [...], "room3": [...] }
    const loader = new THREE.TextureLoader();
    let total = 0, done = 0;
    const keys = ['room1','room2','room3'];
    keys.forEach(k=>{ if(Array.isArray(manifest[k])) total += manifest[k].length; });

    // максимально 50 картин — если больше, обрежем
    total = Math.min(total, 50);

    for(const [roomIndex,roomKey] of keys.map((k,i)=>[i,k])){
      const list = manifest[roomKey] || [];
      for(let i=0;i<list.length && paintingPlanes.length < 50;i++){
        const fname = list[i];
        const url = ASSETS_BASE + fname;
        try{
          const tex = await new Promise((res,rej)=> loader.load(url, res, undefined, rej));
          // вычислим размер плоскости в мировых единицах (масштабируем по tex.aspect)
          const aspect = tex.image.width / tex.image.height;
          const height = 1.0 + Math.random()*0.6; // варьируем размеры
          const width = height * aspect;
          const material = new THREE.MeshStandardMaterial({map:tex});
          const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);

          // позиционирование: распределяем по четырём стенам (front, back, left, right) по рядам
          const roomX = roomIndex * (roomSize.w + 2) - ((3-1)*(roomSize.w+2))/2;
          // вычислим стену и позицию
          const wallIndex = i % 4; // 0..3
          const positionIndex = Math.floor(i/4);
          const cols = Math.ceil((list.length)/4);
          // отступы по стене
          const margin = 0.5;
          const availLen = roomSize.w - margin*2;
          const xInRoom = -roomSize.w/2 + margin + (positionIndex % cols) * Math.min( (availLen / Math.max(1, cols)), availLen);
          const y = 1.6 + Math.floor((i/ (cols*4))) * (height + 0.1); // размещение в столбики по высоте

          // начальные координаты: расположение относительно комнаты центра
          let px=roomX, pz=0, rotY=0;
          // four walls arrangement
          switch(wallIndex){
            case 0: // front wall (z = -d/2)
              px = roomX + xInRoom + width/2;
              pz = -roomSize.d/2 + 0.01;
              rotY = 0;
              break;
            case 1: // back wall
              px = roomX + xInRoom + width/2;
              pz = roomSize.d/2 - 0.01;
              rotY = Math.PI;
              break;
            case 2: // left wall
              px = roomX - roomSize.w/2 + 0.01;
              pz = -roomSize.d/2 + xInRoom;
              rotY = Math.PI/2;
              break;
            case 3: // right wall
              px = roomX + roomSize.w/2 - 0.01;
              pz = -roomSize.d/2 + xInRoom;
              rotY = -Math.PI/2;
              break;
          }

          plane.position.set(px, y, pz);
          plane.rotation.y = rotY;
          plane.userData = {file: fname, room: roomIndex+1, id: fname, meta: descriptions[fname] || {} };

          // подпись (HTML-панель, опционально)
          const label = createLabelElement(fname);
          plane.userData.labelEl = label;

          paintingsGroup.add(plane);
          paintingPlanes.push({mesh:plane, id:fname, meta:plane.userData.meta});
        } catch(err){
          console.warn('Load failed', url, err);
        } finally {
          done++;
          document.getElementById('loadStatus').innerText = Math.round((done/total)*100) + '%';
        }
      }
    }

    // добавить hover area (немного увеличить для raycast)
    paintingPlanes.forEach(p=>{
      p.mesh.geometry.computeBoundingBox();
    });
  }

  function createLabelElement(text){
    const el = document.createElement('div');
    el.className = 'paintingLabel';
    el.innerText = text;
    el.style.display = document.getElementById('showLabels').checked ? 'block' : 'none';
    document.body.appendChild(el);
    return el;
  }

  function toggleLabels(show){
    paintingPlanes.forEach(p=>{
      if(p.mesh.userData.labelEl) p.mesh.userData.labelEl.style.display = show ? 'block' : 'none';
    });
  }

  function addRoomVisuals(){
    // простой пол и стены (не обязательны)
    const floorMat = new THREE.MeshStandardMaterial({color:0xf5f5f5});
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), floorMat);
    floor.rotation.x = -Math.PI/2; floor.position.y = 0;
    scene.add(floor);
  }

  function onResize(){
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }

  function onPointerMove(event){
    mouse.x = ( event.clientX / innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / innerHeight ) * 2 + 1;
  }

  function onDocumentClick(event){
    // raycast — клик на картине откроет описание
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(paintingsGroup.children, true);
    if(intersects.length>0){
      const hit = intersects[0].object;
      showDescription(hit.userData);
    }
  }

  function showDescription(userData){
    if(!userData) return;
    const box = document.getElementById('descriptionBox');
    document.getElementById('descTitle').innerText = userData.meta?.title || userData.file || 'Картина';
    document.getElementById('descText').innerText = userData.meta?.description || 'Описание отсутствует';
    box.style.display = 'block';
    setTimeout(()=> box.style.display = 'none', 15000); // auto-hide через 15s
  }

  function switchToOrbit(){
    controlsFP.unlock && controlsFP.unlock();
    currentControls = controlsOrbit;
    controlsOrbit.enabled = true;
  }
  function switchToFP(){
    controlsOrbit.enabled = false;
    currentControls = controlsFP;
  }

  // анимация и рэйкаст для hover
  function animate(){
    requestAnimationFrame(animate);
    // управление
    if(currentControls===controlsFP){
      // Тут можно обрабатывать WASD движение вручную, но PointerLockControls уже имеет базовую поддержку
    } else {
      controlsOrbit.update();
    }

    // hover detection
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(paintingsGroup.children, true);
    if(intersects.length > 0){
      if(INTERSECTED != intersects[0].object){
        INTERSECTED = intersects[0].object;
        // можно визуально подсветить
        INTERSECTED.material.emissive && (INTERSECTED.material.emissive.setHex(0x222222));
        // показать подпись в позиции курсора
        updateLabelPosition(INTERSECTED);
      }
    } else {
      if(INTERSECTED){
        INTERSECTED.material.emissive && (INTERSECTED.material.emissive.setHex(0x000000));
      }
      INTERSECTED = null;
    }

    // обновить позиции HTML-лейблов
    paintingPlanes.forEach(p=>{
      if(p.mesh.userData.labelEl && p.mesh.visible){
        updateLabelPosition(p.mesh);
      }
    });

    renderer.render(scene, camera);
  }

  function updateLabelPosition(mesh){
    const el = mesh.userData.labelEl;
    if(!el) return;
    const vector = new THREE.Vector3();
    mesh.getWorldPosition(vector);
    vector.project(camera);
    const x = (vector.x * 0.5 + 0.5) * innerWidth;
    const y = ( -vector.y * 0.5 + 0.5) * innerHeight;
    el.style.transform = `translate(-50%,-50%) translate(${x}px, ${y}px)`;
  }

  // === keyboard move (WASD) for pointer lock ===
  (function addWASD(){
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const move = {forward:false,back:false,left:false,right:false};
    document.addEventListener('keydown', e=>{
      if(e.code==='KeyW') move.forward=true;
      if(e.code==='KeyS') move.back=true;
      if(e.code==='KeyA') move.left=true;
      if(e.code==='KeyD') move.right=true;
    });
    document.addEventListener('keyup', e=>{
      if(e.code==='KeyW') move.forward=false;
      if(e.code==='KeyS') move.back=false;
      if(e.code==='KeyA') move.left=false;
      if(e.code==='KeyD') move.right=false;
    });

    const speed = 3.0;
    function tick(){
      if(currentControls===controlsFP && controlsFP.isLocked===true){
        const delta = 0.016;
        direction.z = Number(move.forward) - Number(move.back);
        direction.x = Number(move.right) - Number(move.left);
        direction.normalize();

        if(direction.length()>0){
          const moveVec = new THREE.Vector3(direction.x,0,direction.z).multiplyScalar(speed*delta);
          controlsFP.moveRight(moveVec.x);
          controlsFP.getObject().position.y = Math.max(1.0, controlsFP.getObject().position.y);
          controlsFP.moveForward(moveVec.z);
        }
      }
      requestAnimationFrame(tick);
    }
    tick();
  })();

  </script>
</body>
</html>
