<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Виртуальная 3D-галерея — Sergeywieden</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo="> <!-- фиктивный favicon -->

  <style>
    html,body{height:100%;margin:0;overflow:hidden;font-family:Arial, sans-serif;background:#eee}
    #overlayUI{
      position:fixed;right:12px;top:12px;z-index:20;background:rgba(255,255,255,0.95);
      padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:320px;
    }
    #descriptionBox{
      position:fixed;left:12px;bottom:12px;z-index:30;
      background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:6px;
      max-width:40%;display:none;
    }
    #descTitle{font-weight:700;margin-bottom:6px}
    #enterHint{
      position:fixed;left:50%;bottom:40px;transform:translateX(-50%);z-index:25;
      background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;
    }
    .paintingLabel{
      pointer-events:none;
      background:rgba(255,255,255,0.95);padding:4px 6px;border-radius:4px;font-size:12px;
      position:fixed;transform:translate(-50%,-50%);white-space:nowrap;z-index:19;
    }
    canvas{display:block}
    button, select, input{font-size:13px}
  </style>
</head>
<body>
  <div id="overlayUI">
    <div><strong>3D-галерея</strong></div>
    <div style="font-size:13px;margin-top:6px">
      Комнаты: 1 (A*), 2 (G*), 3 (S*)<br/>
      Управление: WASD + мышь. Клик на картину — описание.
    </div>
    <div style="margin-top:8px">
      <label><input id="showLabels" type="checkbox" checked/> Показывать подписи</label>
    </div>
    <div style="margin-top:6px">
      <button id="resetPos">Сброс позиции</button>
    </div>
    <div style="margin-top:6px">
      <label>Режим:
        <select id="moveMode">
          <option value="fp">1st-person</option>
          <option value="orbit">Orbit</option>
        </select>
      </label>
    </div>
    <div style="margin-top:6px;font-size:12px;color:#666">Загрузка: <span id="loadStatus">0%</span></div>
  </div>

  <div id="descriptionBox"><div id="descTitle"></div><div id="descText" style="white-space:pre-wrap"></div></div>
  <div id="enterHint">Клик по сцене, чтобы начать (Pointer Lock). ESC — выйти.</div>

  <!-- ✅ Современные ES-модули three.js -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // === Конфигурация ===
    const ASSETS_BASE = './assets/';
    if (!window.MANIFEST_PATH) window.MANIFEST_PATH = ASSETS_BASE + 'manifest.json';
    if (!window.DESCRIPTIONS_PATH) window.DESCRIPTIONS_PATH = ASSETS_BASE + 'descriptions.json';

    let scene, camera, renderer, controlsFP, controlsOrbit, currentControls;
    let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    let paintingsGroup = new THREE.Group();
    let paintingPlanes = [];
    let INTERSECTED = null;
    const roomCount = 3;
    const roomSize = {w:12, h:4, d:12};
    let loadTotal = 0, loadDone = 0;

    init();

    async function init() {
      setLoadStatus('Загрузка файлов...');

      try {
        const [manifest, descriptions] = await Promise.all([
          loadJSON(MANIFEST_PATH),
          loadJSON(DESCRIPTIONS_PATH)
        ]);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdddddd);

        camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 400);
        camera.position.set(0, 1.6, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const amb = new THREE.AmbientLight(0xffffff, 0.7);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(5, 10, 5);
        scene.add(amb, dir);

        // создаём комнаты
        const roomsGroup = new THREE.Group();
        const gap = 2;
        for (let i = 0; i < roomCount; i++) {
          const room = new THREE.Group();
          const xOffset = i * (roomSize.w + gap);
          room.position.set(xOffset, 0, 0);
          room.name = `room${i + 1}`;
          addRoomGeometry(room);
          room.userData.index = i;
          roomsGroup.add(room);
        }
        roomsGroup.position.x = -((roomCount - 1) * (roomSize.w + gap)) / 2;
        scene.add(roomsGroup);

        await placePaintings(manifest, descriptions);
        scene.add(paintingsGroup);

        controlsFP = new PointerLockControls(camera, renderer.domElement);
        controlsOrbit = new OrbitControls(camera, renderer.domElement);
        controlsOrbit.enabled = false;
        currentControls = controlsFP;

        renderer.domElement.addEventListener('click', () => {
          if (document.getElementById('moveMode').value === 'fp') {
            controlsFP.lock();
            document.getElementById('enterHint').style.display = 'none';
          }
        });

        window.addEventListener('resize', onResize);
        document.addEventListener('mousemove', onDocumentMouseMove);
        document.addEventListener('click', onDocumentClick);
        document.getElementById('showLabels').addEventListener('change', ev => toggleLabels(ev.target.checked));
        document.getElementById('resetPos').addEventListener('click', () => {
          camera.position.set(0, 1.6, 0);
          camera.rotation.set(0, 0, 0);
        });
        document.getElementById('moveMode').addEventListener('change', ev => {
          if (ev.target.value === 'orbit') switchToOrbit(); else switchToFP();
        });

        setupWASD();
        animate();
        setLoadStatus('Готово');
      } catch (err) {
        console.error(err);
        setLoadStatus('Ошибка: ' + (err.message || err));
      }
    }

    function setLoadStatus(text) {
      const el = document.getElementById('loadStatus');
      if (el) el.innerText = text;
    }

    function loadJSON(url) {
      return fetch(url).then(r => { if (!r.ok) throw new Error('Невозможно загрузить: ' + url); return r.json(); });
    }

    function addRoomGeometry(room) {
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), floorMat);
      floor.rotation.x = -Math.PI / 2;
      room.add(floor);

      const ceilMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), ceilMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = roomSize.h;
      room.add(ceiling);

      const wallMat = new THREE.MeshStandardMaterial({ color: 0xE6E6E6, side: THREE.DoubleSide });
      const wallBack = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.h), wallMat);
      wallBack.position.set(0, roomSize.h / 2, -roomSize.d / 2);
      const wallFront = wallBack.clone(); wallFront.position.z = roomSize.d / 2; wallFront.rotation.y = Math.PI;
      const wallLeft = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d, roomSize.h), wallMat);
      wallLeft.position.set(-roomSize.w / 2, roomSize.h / 2, 0); wallLeft.rotation.y = Math.PI / 2;
      const wallRight = wallLeft.clone(); wallRight.position.x = roomSize.w / 2; wallRight.rotation.y = -Math.PI / 2;

      room.add(wallBack, wallFront, wallLeft, wallRight);
    }

    async function placePaintings(manifest, descriptions) {
      const loader = new THREE.TextureLoader();
      const keys = ['room1', 'room2', 'room3'];
      loadTotal = 0; loadDone = 0;
      keys.forEach(k => { if (Array.isArray(manifest[k])) loadTotal += manifest[k].length; });
      if (loadTotal === 0) loadTotal = 1;

      for (let r = 0; r < 3; r++) {
        const roomKey = keys[r];
        const list = manifest[roomKey] || [];
        for (let i = 0; i < list.length; i++) {
          const fname = list[i];
          const url = ASSETS_BASE + fname;
          try {
            const tex = await new Promise((res, rej) => loader.load(url, res, undefined, rej));
            tex.colorSpace = THREE.SRGBColorSpace;
            const aspect = tex.image.width / tex.image.height;
            const height = 1.0, width = Math.max(0.3, height * aspect);
            const mat = new THREE.MeshStandardMaterial({ map: tex });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), mat);

            const perWall = Math.ceil(list.length / 4);
            const wallIndex = Math.floor(i / perWall) % 4;
            const indexOnWall = i % perWall;
            const margin = 0.5;
            const usableLen = roomSize.w - margin * 2;
            let along = -usableLen / 2 + (indexOnWall + 0.5) * (usableLen / Math.max(1, perWall));

            const gap = 2;
            const roomCenterX = r * (roomSize.w + gap) - ((3 - 1) * (roomSize.w + gap)) / 2;

            let px = roomCenterX, pz = 0, rotY = 0;
            let py = 1.6;
            if (wallIndex === 0) { px += along; pz = -roomSize.d / 2 + 0.01; rotY = 0; }
            else if (wallIndex === 1) { px += along; pz = roomSize.d / 2 - 0.01; rotY = Math.PI; }
            else if (wallIndex === 2) { px = roomCenterX - roomSize.w / 2 + 0.01; pz = along; rotY = Math.PI / 2; }
            else { px = roomCenterX + roomSize.w / 2 - 0.01; pz = along; rotY = -Math.PI / 2; }

            plane.position.set(px, py, pz);
            plane.rotation.y = rotY;
            plane.userData = { file: fname, room: r + 1, meta: descriptions[fname] || {} };

            const frameMat = new THREE.MeshStandardMaterial({ color: 0x6b4226 });
            const frame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.05, height + 0.05, 0.02), frameMat);
            frame.position.copy(plane.position);
            frame.rotation.copy(plane.rotation);
            frame.translateZ(-0.03);

            const label = createLabelElement(fname);
            plane.userData.labelEl = label;

            paintingsGroup.add(frame);
            paintingsGroup.add(plane);
            paintingPlanes.push({ mesh: plane, id: fname, meta: plane.userData.meta });
          } catch (err) {
            console.warn('Не удалось загрузить', url, err);
          } finally {
            loadDone++;
            setLoadStatus(Math.round((loadDone / loadTotal) * 100) + '%');
          }
        }
      }
    }

    function createLabelElement(text) {
      const el = document.createElement('div');
      el.className = 'paintingLabel';
      el.innerText = text;
      el.style.display = document.getElementById('showLabels').checked ? 'block' : 'none';
      document.body.appendChild(el);
      return el;
    }

    function toggleLabels(show) {
      paintingPlanes.forEach(p => {
        if (p.mesh.userData.labelEl) p.mesh.userData.labelEl.style.display = show ? 'block' : 'none';
      });
    }

    function onDocumentMouseMove(e) {
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
    }

    function onDocumentClick() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(paintingsGroup.children.filter(ch => ch.geometry), true);
      if (intersects.length > 0) showDescription(intersects[0].object.userData);
    }

    function showDescription(userData) {
      if (!userData) return;
      const box = document.getElementById('descriptionBox');
      document.getElementById('descTitle').innerText = userData.meta?.title || userData.file || 'Картина';
      const author = userData.meta?.author ? ('\nАвтор: ' + userData.meta.author) : '';
      document.getElementById('descText').innerText = (userData.meta?.description || 'Описание отсутствует') + author;
      box.style.display = 'block';
      setTimeout(() => box.style.display = 'none', 15000);
    }

    function switchToOrbit() { controlsFP.unlock?.(); controlsOrbit.enabled = true; currentControls = controlsOrbit; }
    function switchToFP() { controlsOrbit.enabled = false; currentControls = controlsFP; }

    function animate() {
      requestAnimationFrame(animate);
      if (currentControls === controlsOrbit) controlsOrbit.update();

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(paintingsGroup.children.filter(ch => ch.material), true);
      if (intersects.length > 0) {
        if (INTERSECTED !== intersects[0].object) {
          if (INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x000000);
          INTERSECTED = intersects[0].object;
          if (INTERSECTED.material?.emissive) INTERSECTED.material.emissive.setHex(0x222222);
        }
      } else if (INTERSECTED?.material?.emissive) {
        INTERSECTED.material.emissive.setHex(0x000000);
        INTERSECTED = null;
      }

      paintingPlanes.forEach(p => { if (p.mesh.userData.labelEl && p.mesh.visible) updateLabelPosition(p.mesh); });
      renderer.render(scene, camera);
    }

    function updateLabelPosition(mesh) {
      const el = mesh.userData.labelEl;
      if (!el) return;
      const pos = new THREE.Vector3();
      mesh.getWorldPosition(pos);
      pos.project(camera);
      const x = (pos.x * 0.5 + 0.5) * innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * innerHeight;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
    }

    function onResize() {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    function setupWASD() {
      const move = { forward: false, back: false, left: false, right: false };
      const speed = 3.0;
      document.addEventListener('keydown', e => { if (e.code in move) move[e.code] = true; });
      document.addEventListener('keyup', e => { if (e.code in move) move[e.code] = false; });

      (function tick() {
        requestAnimationFrame(tick);
        if (currentControls === controlsFP && controlsFP.isLocked) {
          const delta = 0.016;
          const dir = new THREE.Vector3(
            (move['KeyD'] ? 1 : 0) - (move['KeyA'] ? 
(move['KeyA'] ? 1 : 0),
            0,
            (move['KeyS'] ? 1 : 0) - (move['KeyW'] ? 1 : 0)
          );
          dir.normalize();
          if (dir.lengthSq() > 0) {
            const moveVec = dir.clone().multiplyScalar(speed * delta);
            controlsFP.moveRight(moveVec.x);
            controlsFP.moveForward(moveVec.z);
            const obj = controlsFP.getObject();
            obj.position.y = Math.max(1.0, obj.position.y);
          }
        }
      })();
    }
  </script>
</body>
</html>
